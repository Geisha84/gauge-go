// Code generated by protoc-gen-go.
// source: spec.proto
// DO NOT EDIT!

/*
Package gauge_messages is a generated protocol buffer package.

It is generated from these files:
	spec.proto

It has these top-level messages:
	ProtoSpec
	ProtoItem
	ProtoScenario
	ProtoTableDrivenScenario
	ProtoStep
	ProtoConcept
	ProtoTags
	Fragment
	Parameter
	ProtoComment
	ProtoTable
	ProtoTableRow
	ProtoStepExecutionResult
	ProtoExecutionResult
	ProtoHookFailure
	ProtoSuiteResult
	ProtoSpecResult
	ProtoStepValue
*/
package gauge_messages

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// / Enumerates various item types that the proto item can contain. Valid types are: Step, Comment, Concept, Scenario, TableDrivenScenario, Table, Tags
type ProtoItem_ItemType int32

const (
	ProtoItem_Step                ProtoItem_ItemType = 1
	ProtoItem_Comment             ProtoItem_ItemType = 2
	ProtoItem_Concept             ProtoItem_ItemType = 3
	ProtoItem_Scenario            ProtoItem_ItemType = 4
	ProtoItem_TableDrivenScenario ProtoItem_ItemType = 5
	ProtoItem_Table               ProtoItem_ItemType = 6
	ProtoItem_Tags                ProtoItem_ItemType = 7
)

var ProtoItem_ItemType_name = map[int32]string{
	1: "Step",
	2: "Comment",
	3: "Concept",
	4: "Scenario",
	5: "TableDrivenScenario",
	6: "Table",
	7: "Tags",
}
var ProtoItem_ItemType_value = map[string]int32{
	"Step":                1,
	"Comment":             2,
	"Concept":             3,
	"Scenario":            4,
	"TableDrivenScenario": 5,
	"Table":               6,
	"Tags":                7,
}

func (x ProtoItem_ItemType) Enum() *ProtoItem_ItemType {
	p := new(ProtoItem_ItemType)
	*p = x
	return p
}
func (x ProtoItem_ItemType) String() string {
	return proto.EnumName(ProtoItem_ItemType_name, int32(x))
}
func (x *ProtoItem_ItemType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ProtoItem_ItemType_value, data, "ProtoItem_ItemType")
	if err != nil {
		return err
	}
	*x = ProtoItem_ItemType(value)
	return nil
}

// / Enum representing the types of Fragment
type Fragment_FragmentType int32

const (
	Fragment_Text      Fragment_FragmentType = 1
	Fragment_Parameter Fragment_FragmentType = 2
)

var Fragment_FragmentType_name = map[int32]string{
	1: "Text",
	2: "Parameter",
}
var Fragment_FragmentType_value = map[string]int32{
	"Text":      1,
	"Parameter": 2,
}

func (x Fragment_FragmentType) Enum() *Fragment_FragmentType {
	p := new(Fragment_FragmentType)
	*p = x
	return p
}
func (x Fragment_FragmentType) String() string {
	return proto.EnumName(Fragment_FragmentType_name, int32(x))
}
func (x *Fragment_FragmentType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Fragment_FragmentType_value, data, "Fragment_FragmentType")
	if err != nil {
		return err
	}
	*x = Fragment_FragmentType(value)
	return nil
}

// / Enum representing types of Parameter.
type Parameter_ParameterType int32

const (
	Parameter_Static         Parameter_ParameterType = 1
	Parameter_Dynamic        Parameter_ParameterType = 2
	Parameter_Special_String Parameter_ParameterType = 3
	Parameter_Special_Table  Parameter_ParameterType = 4
	Parameter_Table          Parameter_ParameterType = 5
)

var Parameter_ParameterType_name = map[int32]string{
	1: "Static",
	2: "Dynamic",
	3: "Special_String",
	4: "Special_Table",
	5: "Table",
}
var Parameter_ParameterType_value = map[string]int32{
	"Static":         1,
	"Dynamic":        2,
	"Special_String": 3,
	"Special_Table":  4,
	"Table":          5,
}

func (x Parameter_ParameterType) Enum() *Parameter_ParameterType {
	p := new(Parameter_ParameterType)
	*p = x
	return p
}
func (x Parameter_ParameterType) String() string {
	return proto.EnumName(Parameter_ParameterType_name, int32(x))
}
func (x *Parameter_ParameterType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Parameter_ParameterType_value, data, "Parameter_ParameterType")
	if err != nil {
		return err
	}
	*x = Parameter_ParameterType(value)
	return nil
}

// / A proto object representing a Specification
// / A specification can contain Scenarios or Steps, besides Comments
type ProtoSpec struct {
	// / Heading describing the Specification
	SpecHeading *string `protobuf:"bytes,1,req,name=specHeading" json:"specHeading,omitempty"`
	// / A collection of items that come under this step
	Items []*ProtoItem `protobuf:"bytes,2,rep,name=items" json:"items,omitempty"`
	// / Flag indicating if this is a Table Driven Specification. The table is defined in the context, this is different from using a table parameter.
	IsTableDriven *bool `protobuf:"varint,3,req,name=isTableDriven" json:"isTableDriven,omitempty"`
	// / Contains a 'before' hook failure message. This happens when the `before_spec` hook has an error.
	PreHookFailure *ProtoHookFailure `protobuf:"bytes,4,opt,name=preHookFailure" json:"preHookFailure,omitempty"`
	// / Contains a 'before' hook failure message. This happens when the `after_hook` hook has an error.
	PostHookFailure *ProtoHookFailure `protobuf:"bytes,5,opt,name=postHookFailure" json:"postHookFailure,omitempty"`
	// / Contains the filename for that holds this specification.
	FileName *string `protobuf:"bytes,6,req,name=fileName" json:"fileName,omitempty"`
	// / Contains a list of tags that are defined at the specification level. Scenario tags are not present here.
	Tags             []string `protobuf:"bytes,7,rep,name=tags" json:"tags,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *ProtoSpec) Reset()         { *m = ProtoSpec{} }
func (m *ProtoSpec) String() string { return proto.CompactTextString(m) }
func (*ProtoSpec) ProtoMessage()    {}

func (m *ProtoSpec) GetSpecHeading() string {
	if m != nil && m.SpecHeading != nil {
		return *m.SpecHeading
	}
	return ""
}

func (m *ProtoSpec) GetItems() []*ProtoItem {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *ProtoSpec) GetIsTableDriven() bool {
	if m != nil && m.IsTableDriven != nil {
		return *m.IsTableDriven
	}
	return false
}

func (m *ProtoSpec) GetPreHookFailure() *ProtoHookFailure {
	if m != nil {
		return m.PreHookFailure
	}
	return nil
}

func (m *ProtoSpec) GetPostHookFailure() *ProtoHookFailure {
	if m != nil {
		return m.PostHookFailure
	}
	return nil
}

func (m *ProtoSpec) GetFileName() string {
	if m != nil && m.FileName != nil {
		return *m.FileName
	}
	return ""
}

func (m *ProtoSpec) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

// / Container for all valid Items under a Specification.
type ProtoItem struct {
	// / Itemtype of the current ProtoItem
	ItemType *ProtoItem_ItemType `protobuf:"varint,1,req,name=itemType,enum=gauge.messages.ProtoItem_ItemType" json:"itemType,omitempty"`
	// / Holds the Step definition. Valid only if ItemType = Step
	Step *ProtoStep `protobuf:"bytes,2,opt,name=step" json:"step,omitempty"`
	// / Holds the Concept definition. Valid only if ItemType = Concept
	Concept *ProtoConcept `protobuf:"bytes,3,opt,name=concept" json:"concept,omitempty"`
	// / Holds the Scenario definition. Valid only if ItemType = Scenario
	Scenario *ProtoScenario `protobuf:"bytes,4,opt,name=scenario" json:"scenario,omitempty"`
	// / Holds the TableDrivenScenario definition. Valid only if ItemType = TableDrivenScenario
	TableDrivenScenario *ProtoTableDrivenScenario `protobuf:"bytes,5,opt,name=tableDrivenScenario" json:"tableDrivenScenario,omitempty"`
	// / Holds the Comment definition. Valid only if ItemType = Comment
	Comment *ProtoComment `protobuf:"bytes,6,opt,name=comment" json:"comment,omitempty"`
	// / Holds the Table definition. Valid only if ItemType = Table
	Table *ProtoTable `protobuf:"bytes,7,opt,name=table" json:"table,omitempty"`
	// / Holds the Tags definition. Valid only if ItemType = Tags
	Tags             *ProtoTags `protobuf:"bytes,8,opt,name=tags" json:"tags,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *ProtoItem) Reset()         { *m = ProtoItem{} }
func (m *ProtoItem) String() string { return proto.CompactTextString(m) }
func (*ProtoItem) ProtoMessage()    {}

func (m *ProtoItem) GetItemType() ProtoItem_ItemType {
	if m != nil && m.ItemType != nil {
		return *m.ItemType
	}
	return ProtoItem_Step
}

func (m *ProtoItem) GetStep() *ProtoStep {
	if m != nil {
		return m.Step
	}
	return nil
}

func (m *ProtoItem) GetConcept() *ProtoConcept {
	if m != nil {
		return m.Concept
	}
	return nil
}

func (m *ProtoItem) GetScenario() *ProtoScenario {
	if m != nil {
		return m.Scenario
	}
	return nil
}

func (m *ProtoItem) GetTableDrivenScenario() *ProtoTableDrivenScenario {
	if m != nil {
		return m.TableDrivenScenario
	}
	return nil
}

func (m *ProtoItem) GetComment() *ProtoComment {
	if m != nil {
		return m.Comment
	}
	return nil
}

func (m *ProtoItem) GetTable() *ProtoTable {
	if m != nil {
		return m.Table
	}
	return nil
}

func (m *ProtoItem) GetTags() *ProtoTags {
	if m != nil {
		return m.Tags
	}
	return nil
}

// / A proto object representing a Scenario
type ProtoScenario struct {
	// / Heading of the given Scenario
	ScenarioHeading *string `protobuf:"bytes,1,req,name=scenarioHeading" json:"scenarioHeading,omitempty"`
	// / Flag to indicate if the Scenario execution failed
	Failed *bool `protobuf:"varint,2,req,name=failed" json:"failed,omitempty"`
	// / Collection of Context steps. The Context steps are executed before every run.
	Contexts []*ProtoItem `protobuf:"bytes,3,rep,name=contexts" json:"contexts,omitempty"`
	// / Collection of Items under a scenario. These could be Steps, Comments, Tags, TableDrivenScenarios or Tables
	ScenarioItems []*ProtoItem `protobuf:"bytes,4,rep,name=scenarioItems" json:"scenarioItems,omitempty"`
	// / Contains a 'before' hook failure message. This happens when the `before_scenario` hook has an error.
	PreHookFailure *ProtoHookFailure `protobuf:"bytes,5,opt,name=preHookFailure" json:"preHookFailure,omitempty"`
	// / Contains a 'after' hook failure message. This happens when the `after_scenario` hook has an error.
	PostHookFailure *ProtoHookFailure `protobuf:"bytes,6,opt,name=postHookFailure" json:"postHookFailure,omitempty"`
	// / Contains a list of tags that are defined at the specification level. Scenario tags are not present here.
	Tags []string `protobuf:"bytes,7,rep,name=tags" json:"tags,omitempty"`
	// / Holds the time taken for executing this scenario.
	ExecutionTime    *int64   `protobuf:"varint,8,opt,name=executionTime" json:"executionTime,omitempty"`
	Skipped          *bool    `protobuf:"varint,9,req,name=skipped" json:"skipped,omitempty"`
	SkipErrors       []string `protobuf:"bytes,10,rep,name=skipErrors" json:"skipErrors,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *ProtoScenario) Reset()         { *m = ProtoScenario{} }
func (m *ProtoScenario) String() string { return proto.CompactTextString(m) }
func (*ProtoScenario) ProtoMessage()    {}

func (m *ProtoScenario) GetScenarioHeading() string {
	if m != nil && m.ScenarioHeading != nil {
		return *m.ScenarioHeading
	}
	return ""
}

func (m *ProtoScenario) GetFailed() bool {
	if m != nil && m.Failed != nil {
		return *m.Failed
	}
	return false
}

func (m *ProtoScenario) GetContexts() []*ProtoItem {
	if m != nil {
		return m.Contexts
	}
	return nil
}

func (m *ProtoScenario) GetScenarioItems() []*ProtoItem {
	if m != nil {
		return m.ScenarioItems
	}
	return nil
}

func (m *ProtoScenario) GetPreHookFailure() *ProtoHookFailure {
	if m != nil {
		return m.PreHookFailure
	}
	return nil
}

func (m *ProtoScenario) GetPostHookFailure() *ProtoHookFailure {
	if m != nil {
		return m.PostHookFailure
	}
	return nil
}

func (m *ProtoScenario) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *ProtoScenario) GetExecutionTime() int64 {
	if m != nil && m.ExecutionTime != nil {
		return *m.ExecutionTime
	}
	return 0
}

func (m *ProtoScenario) GetSkipped() bool {
	if m != nil && m.Skipped != nil {
		return *m.Skipped
	}
	return false
}

func (m *ProtoScenario) GetSkipErrors() []string {
	if m != nil {
		return m.SkipErrors
	}
	return nil
}

// / A proto object representing a TableDrivenScenario
type ProtoTableDrivenScenario struct {
	// / Holds the Underlying scenario that is executed for every row in the table.
	Scenarios        []*ProtoScenario `protobuf:"bytes,1,rep,name=scenarios" json:"scenarios,omitempty"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *ProtoTableDrivenScenario) Reset()         { *m = ProtoTableDrivenScenario{} }
func (m *ProtoTableDrivenScenario) String() string { return proto.CompactTextString(m) }
func (*ProtoTableDrivenScenario) ProtoMessage()    {}

func (m *ProtoTableDrivenScenario) GetScenarios() []*ProtoScenario {
	if m != nil {
		return m.Scenarios
	}
	return nil
}

// / A proto object representing a Step
type ProtoStep struct {
	// / Holds the raw text of the Step as defined in the spec file. This contains the actual parameter values.
	ActualText *string `protobuf:"bytes,1,req,name=actualText" json:"actualText,omitempty"`
	// / Contains the parsed text of the Step. This will have placeholders for the parameters.
	ParsedText *string `protobuf:"bytes,2,req,name=parsedText" json:"parsedText,omitempty"`
	// / Collection of a list of fragments for a Step. A fragment could be either text or parameter.
	Fragments []*Fragment `protobuf:"bytes,3,rep,name=fragments" json:"fragments,omitempty"`
	// / Holds the result from the execution.
	StepExecutionResult *ProtoStepExecutionResult `protobuf:"bytes,4,opt,name=stepExecutionResult" json:"stepExecutionResult,omitempty"`
	XXX_unrecognized    []byte                    `json:"-"`
}

func (m *ProtoStep) Reset()         { *m = ProtoStep{} }
func (m *ProtoStep) String() string { return proto.CompactTextString(m) }
func (*ProtoStep) ProtoMessage()    {}

func (m *ProtoStep) GetActualText() string {
	if m != nil && m.ActualText != nil {
		return *m.ActualText
	}
	return ""
}

func (m *ProtoStep) GetParsedText() string {
	if m != nil && m.ParsedText != nil {
		return *m.ParsedText
	}
	return ""
}

func (m *ProtoStep) GetFragments() []*Fragment {
	if m != nil {
		return m.Fragments
	}
	return nil
}

func (m *ProtoStep) GetStepExecutionResult() *ProtoStepExecutionResult {
	if m != nil {
		return m.StepExecutionResult
	}
	return nil
}

// / Concept is a type of step, that can have multiple Steps.
// / But from a caller's perspective, it is still used as any other Step
// / A proto object representing a Concept
type ProtoConcept struct {
	// / Represents the Step value of a Concept.
	ConceptStep *ProtoStep `protobuf:"bytes,1,req,name=conceptStep" json:"conceptStep,omitempty"`
	// / Collection of Steps in the given concepts.
	Steps []*ProtoItem `protobuf:"bytes,2,rep,name=steps" json:"steps,omitempty"`
	// / Holds the execution result.
	ConceptExecutionResult *ProtoStepExecutionResult `protobuf:"bytes,3,opt,name=conceptExecutionResult" json:"conceptExecutionResult,omitempty"`
	XXX_unrecognized       []byte                    `json:"-"`
}

func (m *ProtoConcept) Reset()         { *m = ProtoConcept{} }
func (m *ProtoConcept) String() string { return proto.CompactTextString(m) }
func (*ProtoConcept) ProtoMessage()    {}

func (m *ProtoConcept) GetConceptStep() *ProtoStep {
	if m != nil {
		return m.ConceptStep
	}
	return nil
}

func (m *ProtoConcept) GetSteps() []*ProtoItem {
	if m != nil {
		return m.Steps
	}
	return nil
}

func (m *ProtoConcept) GetConceptExecutionResult() *ProtoStepExecutionResult {
	if m != nil {
		return m.ConceptExecutionResult
	}
	return nil
}

// / A proto object representing Tags
type ProtoTags struct {
	// / A collection of Tags
	Tags             []string `protobuf:"bytes,1,rep,name=tags" json:"tags,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *ProtoTags) Reset()         { *m = ProtoTags{} }
func (m *ProtoTags) String() string { return proto.CompactTextString(m) }
func (*ProtoTags) ProtoMessage()    {}

func (m *ProtoTags) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

// / A proto object representing Fragment.
// / Fragments, put together make up A Step
type Fragment struct {
	// / Type of Fragment, valid values are Text, Parameter
	FragmentType *Fragment_FragmentType `protobuf:"varint,1,req,name=fragmentType,enum=gauge.messages.Fragment_FragmentType" json:"fragmentType,omitempty"`
	// / Text part of the Fragment, valid only if FragmentType=Text
	Text *string `protobuf:"bytes,2,opt,name=text" json:"text,omitempty"`
	// / Parameter part of the Fragment, valid only if FragmentType=Parameter
	Parameter        *Parameter `protobuf:"bytes,3,opt,name=parameter" json:"parameter,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *Fragment) Reset()         { *m = Fragment{} }
func (m *Fragment) String() string { return proto.CompactTextString(m) }
func (*Fragment) ProtoMessage()    {}

func (m *Fragment) GetFragmentType() Fragment_FragmentType {
	if m != nil && m.FragmentType != nil {
		return *m.FragmentType
	}
	return Fragment_Text
}

func (m *Fragment) GetText() string {
	if m != nil && m.Text != nil {
		return *m.Text
	}
	return ""
}

func (m *Fragment) GetParameter() *Parameter {
	if m != nil {
		return m.Parameter
	}
	return nil
}

// / A proto object representing Fragment.
type Parameter struct {
	// / Type of the Parameter. Valid values: Static, Dynamic, Special_String, Special_Table, Table
	ParameterType *Parameter_ParameterType `protobuf:"varint,1,req,name=parameterType,enum=gauge.messages.Parameter_ParameterType" json:"parameterType,omitempty"`
	// / Holds the value of the parameter
	Value *string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	// / Holds the name of the parameter, used as Key to lookup the value.
	Name *string `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	// / Holds the table value, if parameterType=Table or Special_Table
	Table            *ProtoTable `protobuf:"bytes,4,opt,name=table" json:"table,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *Parameter) Reset()         { *m = Parameter{} }
func (m *Parameter) String() string { return proto.CompactTextString(m) }
func (*Parameter) ProtoMessage()    {}

func (m *Parameter) GetParameterType() Parameter_ParameterType {
	if m != nil && m.ParameterType != nil {
		return *m.ParameterType
	}
	return Parameter_Static
}

func (m *Parameter) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

func (m *Parameter) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Parameter) GetTable() *ProtoTable {
	if m != nil {
		return m.Table
	}
	return nil
}

// / A proto object representing Comment.
type ProtoComment struct {
	// / Text representing the Comment.
	Text             *string `protobuf:"bytes,1,req,name=text" json:"text,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ProtoComment) Reset()         { *m = ProtoComment{} }
func (m *ProtoComment) String() string { return proto.CompactTextString(m) }
func (*ProtoComment) ProtoMessage()    {}

func (m *ProtoComment) GetText() string {
	if m != nil && m.Text != nil {
		return *m.Text
	}
	return ""
}

// / A proto object representing Table.
type ProtoTable struct {
	// / Contains the Headers for the table
	Headers *ProtoTableRow `protobuf:"bytes,1,req,name=headers" json:"headers,omitempty"`
	// / Contains the Rows for the table
	Rows             []*ProtoTableRow `protobuf:"bytes,2,rep,name=rows" json:"rows,omitempty"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *ProtoTable) Reset()         { *m = ProtoTable{} }
func (m *ProtoTable) String() string { return proto.CompactTextString(m) }
func (*ProtoTable) ProtoMessage()    {}

func (m *ProtoTable) GetHeaders() *ProtoTableRow {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *ProtoTable) GetRows() []*ProtoTableRow {
	if m != nil {
		return m.Rows
	}
	return nil
}

// / A proto object representing Table.
type ProtoTableRow struct {
	// / Represents the cells of a given table
	Cells            []string `protobuf:"bytes,1,rep,name=cells" json:"cells,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *ProtoTableRow) Reset()         { *m = ProtoTableRow{} }
func (m *ProtoTableRow) String() string { return proto.CompactTextString(m) }
func (*ProtoTableRow) ProtoMessage()    {}

func (m *ProtoTableRow) GetCells() []string {
	if m != nil {
		return m.Cells
	}
	return nil
}

// / A proto object representing Step Execution result
type ProtoStepExecutionResult struct {
	// / The actual result of the execution
	ExecutionResult *ProtoExecutionResult `protobuf:"bytes,1,opt,name=executionResult" json:"executionResult,omitempty"`
	// / Contains a 'before' hook failure message. This happens when the `before_step` hook has an error.
	PreHookFailure *ProtoHookFailure `protobuf:"bytes,2,opt,name=preHookFailure" json:"preHookFailure,omitempty"`
	// / Contains a 'after' hook failure message. This happens when the `after_step` hook has an error.
	PostHookFailure  *ProtoHookFailure `protobuf:"bytes,3,opt,name=postHookFailure" json:"postHookFailure,omitempty"`
	Skipped          *bool             `protobuf:"varint,4,req,name=skipped" json:"skipped,omitempty"`
	SkippedReason    *string           `protobuf:"bytes,5,opt,name=skippedReason" json:"skippedReason,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *ProtoStepExecutionResult) Reset()         { *m = ProtoStepExecutionResult{} }
func (m *ProtoStepExecutionResult) String() string { return proto.CompactTextString(m) }
func (*ProtoStepExecutionResult) ProtoMessage()    {}

func (m *ProtoStepExecutionResult) GetExecutionResult() *ProtoExecutionResult {
	if m != nil {
		return m.ExecutionResult
	}
	return nil
}

func (m *ProtoStepExecutionResult) GetPreHookFailure() *ProtoHookFailure {
	if m != nil {
		return m.PreHookFailure
	}
	return nil
}

func (m *ProtoStepExecutionResult) GetPostHookFailure() *ProtoHookFailure {
	if m != nil {
		return m.PostHookFailure
	}
	return nil
}

func (m *ProtoStepExecutionResult) GetSkipped() bool {
	if m != nil && m.Skipped != nil {
		return *m.Skipped
	}
	return false
}

func (m *ProtoStepExecutionResult) GetSkippedReason() string {
	if m != nil && m.SkippedReason != nil {
		return *m.SkippedReason
	}
	return ""
}

// / A proto object representing the result of an execution
type ProtoExecutionResult struct {
	// / Flag to indicate failure
	Failed *bool `protobuf:"varint,1,req,name=failed" json:"failed,omitempty"`
	// / Flag to indicate if the error is recoverable from.
	RecoverableError *bool `protobuf:"varint,2,opt,name=recoverableError" json:"recoverableError,omitempty"`
	// / The actual error message.
	ErrorMessage *string `protobuf:"bytes,3,opt,name=errorMessage" json:"errorMessage,omitempty"`
	// / Stacktrace of the error
	StackTrace *string `protobuf:"bytes,4,opt,name=stackTrace" json:"stackTrace,omitempty"`
	// / Byte array containing screenshot taken at the time of failure.
	ScreenShot []byte `protobuf:"bytes,5,opt,name=screenShot" json:"screenShot,omitempty"`
	// / Holds the time taken for executing this scenario.
	ExecutionTime *int64 `protobuf:"varint,6,req,name=executionTime" json:"executionTime,omitempty"`
	// / Additional information at exec time to be available on reports
	Message          []string `protobuf:"bytes,7,rep,name=message" json:"message,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *ProtoExecutionResult) Reset()         { *m = ProtoExecutionResult{} }
func (m *ProtoExecutionResult) String() string { return proto.CompactTextString(m) }
func (*ProtoExecutionResult) ProtoMessage()    {}

func (m *ProtoExecutionResult) GetFailed() bool {
	if m != nil && m.Failed != nil {
		return *m.Failed
	}
	return false
}

func (m *ProtoExecutionResult) GetRecoverableError() bool {
	if m != nil && m.RecoverableError != nil {
		return *m.RecoverableError
	}
	return false
}

func (m *ProtoExecutionResult) GetErrorMessage() string {
	if m != nil && m.ErrorMessage != nil {
		return *m.ErrorMessage
	}
	return ""
}

func (m *ProtoExecutionResult) GetStackTrace() string {
	if m != nil && m.StackTrace != nil {
		return *m.StackTrace
	}
	return ""
}

func (m *ProtoExecutionResult) GetScreenShot() []byte {
	if m != nil {
		return m.ScreenShot
	}
	return nil
}

func (m *ProtoExecutionResult) GetExecutionTime() int64 {
	if m != nil && m.ExecutionTime != nil {
		return *m.ExecutionTime
	}
	return 0
}

func (m *ProtoExecutionResult) GetMessage() []string {
	if m != nil {
		return m.Message
	}
	return nil
}

// / A proto object representing a pre-hook failure.
// / Used to hold failure information for before_suite, before_spec, before_scenario and before_spec hooks.
type ProtoHookFailure struct {
	// / Stacktrace from the failure
	StackTrace *string `protobuf:"bytes,1,req,name=stackTrace" json:"stackTrace,omitempty"`
	// / Error message from the failure
	ErrorMessage *string `protobuf:"bytes,2,req,name=errorMessage" json:"errorMessage,omitempty"`
	// / Byte array holding the screenshot taken at the time of failure.
	ScreenShot       []byte `protobuf:"bytes,3,opt,name=screenShot" json:"screenShot,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ProtoHookFailure) Reset()         { *m = ProtoHookFailure{} }
func (m *ProtoHookFailure) String() string { return proto.CompactTextString(m) }
func (*ProtoHookFailure) ProtoMessage()    {}

func (m *ProtoHookFailure) GetStackTrace() string {
	if m != nil && m.StackTrace != nil {
		return *m.StackTrace
	}
	return ""
}

func (m *ProtoHookFailure) GetErrorMessage() string {
	if m != nil && m.ErrorMessage != nil {
		return *m.ErrorMessage
	}
	return ""
}

func (m *ProtoHookFailure) GetScreenShot() []byte {
	if m != nil {
		return m.ScreenShot
	}
	return nil
}

// / A proto object representing the result of entire Suite execution.
type ProtoSuiteResult struct {
	// / Contains the result from the execution
	SpecResults []*ProtoSpecResult `protobuf:"bytes,1,rep,name=specResults" json:"specResults,omitempty"`
	// / Contains a 'before' hook failure message. This happens when the `before_suite` hook has an error
	PreHookFailure *ProtoHookFailure `protobuf:"bytes,2,opt,name=preHookFailure" json:"preHookFailure,omitempty"`
	// / Contains a 'after' hook failure message. This happens when the `after_suite` hook has an error
	PostHookFailure *ProtoHookFailure `protobuf:"bytes,3,opt,name=postHookFailure" json:"postHookFailure,omitempty"`
	// / Flag to indicate failure
	Failed *bool `protobuf:"varint,4,req,name=failed" json:"failed,omitempty"`
	// / Holds the count of number of Specifications that failed.
	SpecsFailedCount *int32 `protobuf:"varint,5,req,name=specsFailedCount" json:"specsFailedCount,omitempty"`
	// / Holds the time taken for executing the whole suite.
	ExecutionTime *int64 `protobuf:"varint,6,opt,name=executionTime" json:"executionTime,omitempty"`
	// / Holds a metric indicating the success rate of the execution.
	SuccessRate *float32 `protobuf:"fixed32,7,req,name=successRate" json:"successRate,omitempty"`
	// / The environment against which execution was done
	Environment *string `protobuf:"bytes,8,opt,name=environment" json:"environment,omitempty"`
	// / Tag expression used for filtering specification
	Tags *string `protobuf:"bytes,9,opt,name=tags" json:"tags,omitempty"`
	// / Project name
	ProjectName *string `protobuf:"bytes,10,req,name=projectName" json:"projectName,omitempty"`
	// / Timestamp of when execution started
	Timestamp         *string `protobuf:"bytes,11,req,name=timestamp" json:"timestamp,omitempty"`
	SpecsSkippedCount *int32  `protobuf:"varint,12,req,name=specsSkippedCount" json:"specsSkippedCount,omitempty"`
	XXX_unrecognized  []byte  `json:"-"`
}

func (m *ProtoSuiteResult) Reset()         { *m = ProtoSuiteResult{} }
func (m *ProtoSuiteResult) String() string { return proto.CompactTextString(m) }
func (*ProtoSuiteResult) ProtoMessage()    {}

func (m *ProtoSuiteResult) GetSpecResults() []*ProtoSpecResult {
	if m != nil {
		return m.SpecResults
	}
	return nil
}

func (m *ProtoSuiteResult) GetPreHookFailure() *ProtoHookFailure {
	if m != nil {
		return m.PreHookFailure
	}
	return nil
}

func (m *ProtoSuiteResult) GetPostHookFailure() *ProtoHookFailure {
	if m != nil {
		return m.PostHookFailure
	}
	return nil
}

func (m *ProtoSuiteResult) GetFailed() bool {
	if m != nil && m.Failed != nil {
		return *m.Failed
	}
	return false
}

func (m *ProtoSuiteResult) GetSpecsFailedCount() int32 {
	if m != nil && m.SpecsFailedCount != nil {
		return *m.SpecsFailedCount
	}
	return 0
}

func (m *ProtoSuiteResult) GetExecutionTime() int64 {
	if m != nil && m.ExecutionTime != nil {
		return *m.ExecutionTime
	}
	return 0
}

func (m *ProtoSuiteResult) GetSuccessRate() float32 {
	if m != nil && m.SuccessRate != nil {
		return *m.SuccessRate
	}
	return 0
}

func (m *ProtoSuiteResult) GetEnvironment() string {
	if m != nil && m.Environment != nil {
		return *m.Environment
	}
	return ""
}

func (m *ProtoSuiteResult) GetTags() string {
	if m != nil && m.Tags != nil {
		return *m.Tags
	}
	return ""
}

func (m *ProtoSuiteResult) GetProjectName() string {
	if m != nil && m.ProjectName != nil {
		return *m.ProjectName
	}
	return ""
}

func (m *ProtoSuiteResult) GetTimestamp() string {
	if m != nil && m.Timestamp != nil {
		return *m.Timestamp
	}
	return ""
}

func (m *ProtoSuiteResult) GetSpecsSkippedCount() int32 {
	if m != nil && m.SpecsSkippedCount != nil {
		return *m.SpecsSkippedCount
	}
	return 0
}

// / A proto object representing the result of Spec execution.
type ProtoSpecResult struct {
	// / Represents the corresponding Specification
	ProtoSpec *ProtoSpec `protobuf:"bytes,1,req,name=protoSpec" json:"protoSpec,omitempty"`
	// / Holds the number of Scenarios executed
	ScenarioCount *int32 `protobuf:"varint,2,req,name=scenarioCount" json:"scenarioCount,omitempty"`
	// / Holds the number of Scenarios failed
	ScenarioFailedCount *int32 `protobuf:"varint,3,req,name=scenarioFailedCount" json:"scenarioFailedCount,omitempty"`
	// / Flag to indicate failure
	Failed *bool `protobuf:"varint,4,req,name=failed" json:"failed,omitempty"`
	// / Holds the row numbers, which caused the execution to fail.
	FailedDataTableRows []int32 `protobuf:"varint,5,rep,name=failedDataTableRows" json:"failedDataTableRows,omitempty"`
	// / Holds the time taken for executing the spec.
	ExecutionTime        *int64 `protobuf:"varint,6,opt,name=executionTime" json:"executionTime,omitempty"`
	Skipped              *bool  `protobuf:"varint,7,req,name=skipped" json:"skipped,omitempty"`
	ScenarioSkippedCount *int32 `protobuf:"varint,9,req,name=scenarioSkippedCount" json:"scenarioSkippedCount,omitempty"`
	XXX_unrecognized     []byte `json:"-"`
}

func (m *ProtoSpecResult) Reset()         { *m = ProtoSpecResult{} }
func (m *ProtoSpecResult) String() string { return proto.CompactTextString(m) }
func (*ProtoSpecResult) ProtoMessage()    {}

func (m *ProtoSpecResult) GetProtoSpec() *ProtoSpec {
	if m != nil {
		return m.ProtoSpec
	}
	return nil
}

func (m *ProtoSpecResult) GetScenarioCount() int32 {
	if m != nil && m.ScenarioCount != nil {
		return *m.ScenarioCount
	}
	return 0
}

func (m *ProtoSpecResult) GetScenarioFailedCount() int32 {
	if m != nil && m.ScenarioFailedCount != nil {
		return *m.ScenarioFailedCount
	}
	return 0
}

func (m *ProtoSpecResult) GetFailed() bool {
	if m != nil && m.Failed != nil {
		return *m.Failed
	}
	return false
}

func (m *ProtoSpecResult) GetFailedDataTableRows() []int32 {
	if m != nil {
		return m.FailedDataTableRows
	}
	return nil
}

func (m *ProtoSpecResult) GetExecutionTime() int64 {
	if m != nil && m.ExecutionTime != nil {
		return *m.ExecutionTime
	}
	return 0
}

func (m *ProtoSpecResult) GetSkipped() bool {
	if m != nil && m.Skipped != nil {
		return *m.Skipped
	}
	return false
}

func (m *ProtoSpecResult) GetScenarioSkippedCount() int32 {
	if m != nil && m.ScenarioSkippedCount != nil {
		return *m.ScenarioSkippedCount
	}
	return 0
}

// / A proto object representing a Step value.
type ProtoStepValue struct {
	// / The actual string value describing he Step
	StepValue *string `protobuf:"bytes,1,req,name=stepValue" json:"stepValue,omitempty"`
	// / The parameterized string value describing he Step. The parameters are replaced with placeholders.
	ParameterizedStepValue *string `protobuf:"bytes,2,req,name=parameterizedStepValue" json:"parameterizedStepValue,omitempty"`
	// / A collection of strings representing the parameters.
	Parameters       []string `protobuf:"bytes,3,rep,name=parameters" json:"parameters,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *ProtoStepValue) Reset()         { *m = ProtoStepValue{} }
func (m *ProtoStepValue) String() string { return proto.CompactTextString(m) }
func (*ProtoStepValue) ProtoMessage()    {}

func (m *ProtoStepValue) GetStepValue() string {
	if m != nil && m.StepValue != nil {
		return *m.StepValue
	}
	return ""
}

func (m *ProtoStepValue) GetParameterizedStepValue() string {
	if m != nil && m.ParameterizedStepValue != nil {
		return *m.ParameterizedStepValue
	}
	return ""
}

func (m *ProtoStepValue) GetParameters() []string {
	if m != nil {
		return m.Parameters
	}
	return nil
}

func init() {
	proto.RegisterEnum("gauge.messages.ProtoItem_ItemType", ProtoItem_ItemType_name, ProtoItem_ItemType_value)
	proto.RegisterEnum("gauge.messages.Fragment_FragmentType", Fragment_FragmentType_name, Fragment_FragmentType_value)
	proto.RegisterEnum("gauge.messages.Parameter_ParameterType", Parameter_ParameterType_name, Parameter_ParameterType_value)
}
